#hist(log_returns$FTSE100, main = "FTSE100 daily log-returns", col = "blue", breaks = 100)
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(log_returns_sp500, level = 0.95)
VaR_forecast_sp500$GARCH_param
dates_vector <- index(index_prices)
xts_conditional_variances <- xts(VaR_forecast_sp500$ConditionalVariances, order.by = as.Date(dates_vector)+1)
# Plot the conditional variances as a time series
plot(sqrt(xts_conditional_variances), type="l",xlab = "Garch Standard Deviation", main="Conditional Variances of SP500", col="blue")
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(log_returns$SP500,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data SP500")
quantile(log_returns$SP500,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
index_prices = get(load(here("Data/indices.rda")))
start_analysis_date <-"2005-01-01/"
index_prices = index_prices[start_analysis_date,]
par(mfrow = c(2,1), ## set 2 charts in 1 row
cex = 0.6) ## labels are now 60% of their normal size
#plot(index_prices$SP500, main = "SP500 monthly price", col = "blue")
#plot(index_prices$FTSE100,main = "FTSE100 monthly price", col = "blue")
log_returns_sp500 = CalculateReturns(index_prices$SP500, method = "log")[-1]
log_returns_fste100 = CalculateReturns(index_prices$FTSE100, method = "log")[-1]
log_returns = CalculateReturns(index_prices)[-1]
number_of_bins = round(10 *log(length(log_returns)))
#hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
#hist(log_returns$FTSE100, main = "FTSE100 daily log-returns", col = "blue", breaks = 100)
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(log_returns_sp500, level = 0.95)
VaR_forecast_sp500$GARCH_param
dates_vector <- index(index_prices)
xts_conditional_variances <- xts(VaR_forecast_sp500$ConditionalVariances, order.by = as.Date(dates_vector)+1)
# Plot the conditional variances as a time series
plot(sqrt(xts_conditional_variances), type="l",xlab = "Garch Standard Deviation", main="Garch Standard Deviation by date", col="blue")
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(log_returns$SP500,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data SP500")
quantile(log_returns$SP500,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
here()
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
index_prices = get(load(here("Data/indices.rda")))
start_analysis_date <-"2005-01-01/"
index_prices = index_prices[start_analysis_date,]
par(mfrow = c(2,1), ## set 2 charts in 1 row
cex = 0.6) ## labels are now 60% of their normal size
#plot(index_prices$SP500, main = "SP500 monthly price", col = "blue")
#plot(index_prices$FTSE100,main = "FTSE100 monthly price", col = "blue")
log_returns_sp500 = CalculateReturns(index_prices$SP500, method = "log")[-1]
log_returns_fste100 = CalculateReturns(index_prices$FTSE100, method = "log")[-1]
log_returns = CalculateReturns(index_prices)[-1]
number_of_bins = round(10 *log(length(log_returns)))
#hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
#hist(log_returns$FTSE100, main = "FTSE100 daily log-returns", col = "blue", breaks = 100)
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(log_returns_sp500, level = 0.95)
VaR_forecast_sp500$GARCH_param
dates_vector <- index(index_prices)
xts_conditional_variances <- xts(VaR_forecast_sp500$ConditionalVariances, order.by = as.Date(dates_vector)+1)
# Plot the conditional variances as a time series
plot(sqrt(xts_conditional_variances), type="l",xlab = "Garch Standard Deviation", main="Garch Standard Deviation by date", col="blue")
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(log_returns$SP500,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data SP500")
quantile(log_returns$SP500,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
}
theta0 <- c(1, 0.1, 0.8)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
plot(data,type="l")
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
}
theta0 <- c(1, 0.1, 0.8)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
plot(data,type="l")
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data"))
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data")
print(data)
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
y
}
theta0 <- c(1, 0.1, 0.8)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data")
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
VaR_forecast_sp500$GARCH_param
# Plot the conditional variances as a time series
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(data, main = "data daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(data,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data ")
quantile(data,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
y
}
theta0 <- c(1, 0.1, 0.5)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data")
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
VaR_forecast_sp500$GARCH_param
# Plot the conditional variances as a time series
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(data, main = "data daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(data,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data ")
quantile(data,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
y
}
theta0 <- c(1, 0.4, 0.5)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data")
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
VaR_forecast_sp500$GARCH_param
# Plot the conditional variances as a time series
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(data, main = "data daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(data,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data ")
quantile(data,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
f_generate_datas <- function(theta, n)
{
omega <- theta[1]
alpha <- theta[2]
beta <- theta[3]
epsilon <- rnorm(n)  # Random shocks from a standard normal distribution
sigma2 <- rep(0, n)  # Conditional variance sigma squared
y <- rep(0, n)       # Returns y
# Set initial values for sigma2 and y
sigma2[1] <- omega / (1 - alpha - beta)
y[1] <- sqrt(sigma2[1]) * epsilon[1]
# Simulate data using the GARCH(1,1) process
for(t in 2:n) {
sigma2[t] <- omega + alpha * y[t-1]^2 + beta * sigma2[t-1]
y[t] <- sqrt(sigma2[t]) * epsilon[t]
}
y
}
theta0 <- c(1, 0.1, 0.8)
data = f_generate_datas(theta0, 10000)
number_of_bins = round(10 *log(length(data)))
plot(data,type="l", min = -1, max = 1, xlab = "Time", ylab = "Data", main = "Simulated Garch(1,1) data")
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(data, level = 0.95)
VaR_forecast_sp500$GARCH_param
# Plot the conditional variances as a time series
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(data, main = "data daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(data,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data ")
quantile(data,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
library("here")
library("xts")
library("PerformanceAnalytics")
source(here("Code/f_forecast_var.R"))
source(here("Code/functions.R"))
index_prices = get(load(here("Data/indices.rda")))
start_analysis_date <-"2005-01-01/"
index_prices = index_prices[start_analysis_date,]
par(mfrow = c(2,1), ## set 2 charts in 1 row
cex = 0.6) ## labels are now 60% of their normal size
#plot(index_prices$SP500, main = "SP500 monthly price", col = "blue")
#plot(index_prices$FTSE100,main = "FTSE100 monthly price", col = "blue")
log_returns_sp500 = CalculateReturns(index_prices$SP500, method = "log")[-1]
log_returns_fste100 = CalculateReturns(index_prices$FTSE100, method = "log")[-1]
log_returns = CalculateReturns(index_prices)[-1]
number_of_bins = round(10 *log(length(log_returns)))
#hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
#hist(log_returns$FTSE100, main = "FTSE100 daily log-returns", col = "blue", breaks = 100)
# Compute the VaR forecast for the SP500 index
VaR_forecast_sp500 = f_forecast_var(log_returns_sp500, level = 0.95)
VaR_forecast_sp500$GARCH_param
dates_vector <- index(index_prices)
xts_conditional_variances <- xts(VaR_forecast_sp500$ConditionalVariances, order.by = as.Date(dates_vector)+1)
# Plot the conditional variances as a time series
plot(sqrt(xts_conditional_variances), type="l",xlab = "Garch Standard Deviation", main="Garch Standard Deviation by date", col="blue")
plot(store$objective_values, type = 'l', xlab = "Iteration", ylab = "Objective Function Value",
main = "Objective Function Value Over Iterations")
hist(log_returns$SP500, main = "SP500 daily log-returns", col = "blue", breaks = 100)
abline(v=VaR_forecast_sp500$VaR_Forecast, col="red", lwd=2 )
abline(v=quantile(log_returns$SP500,0.05), col="black", lwd=2 )
legend("topright", legend=c("VaR from Garch", "VaR from data"), col=c("red", "black"), lty=1:1, cex=0.8)
print("VaR from data SP500")
quantile(log_returns$SP500,0.05)
print("Var from Garch")
VaR_forecast_sp500$VaR_Forecast
install.packages("rugarch")
# Load the rugarch package
library(rugarch)
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
level <- 0.95
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
# Print the VaR
print(VaR)
fit$coef
coef(fit)
VaR_forecast_sp500$GARCH_param
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
# Print the VaR
print(VaR)
VaR_forecast_sp500$VaR_Forecast
quantile(log_returns$SP500,0.05)
f_test_rugarch(log_returns_sp500)
f_test_rugarch <- function(log_returns)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
level <- 0.95
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
# Print the VaR
prinT("VaR and params from rugarch")
print(VaR)
print(coef(fit))
}
f_test_rugarch(log_returns_sp500)
f_test_rugarch <- function(log_returns)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
level <- 0.95
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
# Print the VaR
print("VaR and params from rugarch")
print(VaR)
print(coef(fit))
}
f_test_rugarch(log_returns_sp500)
f_test_rugarch <- function(log_returns)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
level <- 0.95
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
cat("VaR and params from rugarch:\nVaR:", VaR, "\nParameters:", toString(coef(fit)), "\n")
}
f_test_rugarch(log_returns_sp500)
f_test_rugarch <- function(log_returns)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
level <- 0.95
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
cat("VaR and Params from rugarch:\nVaR:", VaR, "\nParameters:", (coef(fit)), "\n")
}
f_test_rugarch(log_returns_sp500)
f_test_rugarch <- function(log_returns,level)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
cat("VaR and Params from rugarch:\nVaR:", VaR, "\nParameters:", (coef(fit)), "\n")
}
f_test_rugarch(log_returns_sp500,0.95)
f_test_rugarch <- function(log_returns,level)
{
# Load the rugarch package
library(rugarch)
#Y is the vector of log-returns
# Specify the GARCH(1,1) model with normal distribution for the errors
spec <- ugarchspec(variance.model = list(garchOrder = c(1,1)),
mean.model = list(armaOrder = c(0,0), include.mean = FALSE),
distribution.model = "norm")
# Fit the GARCH model
fit <- ugarchfit(spec = spec, data = log_returns_sp500)
# Summary of the fitted model
summary(fit)
# Extract the conditional variances (sigmas)
sigma_t <- sigma(fit)
# Compute the VaR at the desired confidence level, e.g., 95%
VaR <- qnorm(1 - level) * tail(sigma_t, 1)
cat("VaR and Params from rugarch:\nVaR:", VaR, "\nParameters:", (coef(fit)), "\n")
return(list(VaR = VaR, Params = coef(fit), Sigma = sigma_t))
}
f_test_rugarch(log_returns_sp500,0.95)
